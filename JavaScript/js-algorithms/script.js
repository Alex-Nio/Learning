//!================================================================
//?======================= Сортировка =============================
//!================================================================
/*

Обычный обход по массиву имеет сложность O(n),
где n — количество элементов массива.
Если внутри этого цикла добавить ещё один,
который также будет проходить по всем элементам массива,
то сложность внешнего цикла возрастёт до O(n2).

*/

//? Сортировка пузырьком
// Перебирает весь массив элементов,
// сравнивая два соседних элемента друг с другом
// и меняя их местами в соответствии с условиями.
// Элементы с большим значением опускаются вниз массива, а элементы с наименьшим значением поднимаются вверх, подобно пузырькам газа.

const bubbleSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Меняем значения переменных
      }
    }
  }
};

/*

*Шаги реализации:

Запускаем цикл i по массиву.

Запускаем внутренний цикл j, который идёт от 0 до arr.length - i.
Это ускоряет алгоритм, так как он не проходит по уже отсортированным элементам.

Во внутреннем цикле проверяем соседние элементы и меняем их местами, если сосед слева больше соседа справа.

*/

/*

*Сложность алгоритма: O(n2),
где n — количество элементов массива.
Так как мы запускаем вложенный цикл,
сложность алгоритма равна O(n2)

*/

//? Сортировка выбором
/*

Этот алгоритм сортировки
при каждой итерации проходит по неотсортированной части массива,
находит минимальный элемент и переносит его в начало массива.

*/
const selectedSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    let min = i;

    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min] > arr[j]) {
        min = j; // Меняем значение переменной на наибольшее значение
      }
    }

    [arr[i], arr[min]] = [arr[min], arr[i]]; // Меняем значения переменных
  }
};

/*

*Шаги реализации:

Запускаем цикл i по массиву.

Внутри цикла создаём переменную, равную итерации цикла min = i.

Запускаем внутренний цикл j по оставшимся элементам массива до его конца.

Если элемент arr[min] > arr[j], то присваиваем min значение j.

По окончании внутреннего цикла j переменная min хранит индекс наименьшего неотсортированного элемента массива.

Меняем местами элементы с индексами i и min.

*/

/*

*Сложность алгоритма: O(n2).

*/

//? Циклическая сортировка
/*

Основной идеей алгоритма циклической сортировки является разложение массива на циклы. Затем, внутри этих циклов происходят перестановки элементов до тех пор, пока все циклы не завершатся и массив не будет отсортирован.

*/

function cycleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let value = arr[i];
    let position = i;

    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < value) {
        position++;
      }
    }
    if (position === i) {
      continue;
    }
    while (value === arr[position]) { // Избавляемся от дубликатов
      position++;
    }

    [arr[position], value] = [value, arr[position]]; // Меняем значения переменных

    while (position !== i) { // Запускаем цикл в обратную сторону
      position = i;
      for (let k = i + 1; k < arr.length; k++) {
        if (arr[k] < value) {
          position++;
        }
      }
      while (value === arr[position]) { // Избавляемся от дубликатов
        position++;
      }
      [arr[position], value] = [value, arr[position]]; // Меняем значения пременных
    }
  }
  return arr;
}

/*

*Шаги реализации:

Запускаем цикл i, который должен пройти по всему массиву.

Создаём временную переменную position, которая будет равна i.

Запускаем внутренний цикл j, который перебирает всех соседей справа.

Когда внутри цикла j находим элемент, который меньше arr[i], увеличиваем position на единицу.

Если значение position равно i, переходим к следующей итерации внешнего цикла i.

Пропускаем дубликаты, сравнивая значения элементов под индексами position и i с помощью цикла.

Меняем местами элементы под индексами i и position.

Запускаем цикл, пока position не будет ссылаться на i.

Повторяем все операции, описанные внутри цикла j.

*/

/*

*Сложность алгоритма: O(n2).

*/

//? Быстрая сортировка
/*

Он определяет так называемый «стержень»
и разбивает массив на подмассивы относительно «стержня»,
которые затем сортируются.

*/

const partition = (arr, start, end) => {
  const pivot = arr[end]; // Определяем опорный элемент
  let i = start; // Определяем индекс, по которому делим массив на две части

  for (let j = start; j <= end - 1; j++) {
    if (arr[j] <= pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]]; // Меняем значения переменных
      i++;
    }
  }

  [arr[i], arr[end]] = [arr[end], arr[i]]; // Меняем значения переменных
  return i;
};

const quickSort = (arr, start, end) => {
  if (start < end) { // Условия запуска рекурсии
    const pi = partition(arr, start, end); // Получаем индекс

    quickSort(arr, start, pi - 1);
    quickSort(arr, pi + 1, end);
  }
};

/*

*Шаги реализации:

Проверяем что указатель на начало массива start не совпадает с указателем на конец массива end.

Если условие выполняется, находим индекс элемента, который разделяет массив на две части pi.

Когда pi найден, рекурсивно запускаем quickSort для каждой из получившихся частей (от start до pi - 1) и (от pi + 1 до end).

При нахождении pi мы определяем pivot — опорный элемент и i — индекс, по которому будем делить массив.

Запускаем цикл по массиву j до предпоследнего элемента. При нахождении элемента, который меньше или равен pivot меняем местами arr[i] и arr[j] и инкрементируем i .

После завершения цикла меняем местами arr[i] и arr[end] и возвращаем i.

*/

/*

*Сложность алгоритма в среднем: O(n * log n).
*Сложность алгоритма в худшем случае: O(n2).
Худшим для алгоритма быстрой сортировки можно назвать случай,
когда опорный элемент pivot имеет максимальное или минимальное значение во всём массиве.


*Алгоритм следует использовать в следующих случаях:

При обработке большого объема входных данных.

Когда требуется использовать наиболее быстрый алгоритм
(в среднем этот алгоритм быстрее, чем рассмотренные ранее,
но необходимо учитывать возможные негативные сценарии).

*/

//!================================================================
//?========================= Поиск ================================
//!================================================================

//? Линейный поиск

/*

Линейный поиск — это самый примитивный алгоритм поиска,
который работает как с отсортированными,
так и с не отсортированными массивами.

*/

const linearSearch = (arr, findEl) => {
	for (let i = 0; i < arr.length; i++) {
		if (arr[i] === findEl) {
			return i
		}
	}
	return -1
}

/*

*Сложность алгоритма: О(n).

*Алгоритм следует использовать в следующих случаях:

Когда массив входных данных невелик.
Если массив данных неупорядоченный.

*/

//? Бинарный поиск
/*

Основная идея бинарного поиска заключается в делении массива по полам
и отсеивании не подходящей части.
!Алгоритм имеет смысл использовать только с отсортированными массивами.

*/

const binarySearch = (arr, findItem) => {
  let start = 0;
  let end = arr.length - 1;

  while (start <= end) {
    let mid = Math.floor((start + end) / 2);

    if (arr[mid] === findItem) {
      return mid;
    }

    if (arr[mid] < findItem) {
      start = mid + 1; // Отбрасываем левую часть массива
    } else {
      end = mid - 1; // Отбрасываем правую часть массива
    }
  }

  return -1;
};

/*

*Сложность алгоритма в лучшем случае: O(1).
*Сложность алгоритма в среднем: O(log_n).

*Алгоритм следует использовать в следующих случаях:

Когда входной массив отсортирован.
Когда нам необходимо максимально производительное решение.

*/

//? Поиск в глубину (Depth-First Search)
/*

Алгоритм обхода или поиска в таких структурах данных,
как деревья или графы. Основан на такой структуре данных, как стек.
Алгоритм начинает работу с корневого узла
(в случае графа в качестве корневого узла выбирается какой-либо произвольный узел)
и прежде чем вернуться назад, проходит как можно дальше по каждой ветви.

*/

//! Пример кода в дереве:
const dfsTree = (tree, start) => {
  const stack = [start];

  while (stack.length > 0) {
    const vert = stack.shift(); // Выбираем первую вершину из стека

    if (tree[vert]) {
      stack.unshift(...tree[vert]); // Добавляем вершины в начало стека
    }
  }
};

//! Пример кода в графе:
const dfsGraph = (graph, start) => {
  const visited = {};
  const stack = [start];

  while (stack.length !== 0) {
    const vert = stack.shift(); // Выбираем первую вершину из стека

    if (!visited[vert]) {
      visited[vert] = true; // Отмечаем вершину как пройденую, если ранее не проходили её
    }

    if (graph[vert]) {
      for (let subVert of graph[vert]) {
        if (!visited[subVert]) {
          stack.unshift(subVert); // Добавляем вершину в начало стека
        }
      }
    }
  }
};

/*

*Сложность алгоритма: O(V + E).

*Алгоритм следует использовать в следующих случаях:

Когда мы знаем, что искомая вершина находится дальше всего от стартовой,
или если граф имеет большую ширину.

Когда нам необходимо найти пути между вершинами.

*/

//? Поиск в ширину (Breadth-First Search)
/*

Алгоритм поиска в ширину очень похож на описанный выше алгоритм поиска в глубину,
отличается лишь тем, что в начале проходит все соседние узлы начальной вершины,
потом все соседние узлы соседних вершин, и так далее, пока не пройдёт весь граф или не найдёт искомую вершину.
Ещё одно отличие заключается в том,
что основан этот алгоритм на такой структуре данных, как очередь.

*/

//! Пример кода в дереве
const bfsTree = (tree, start) => {
  const queue = [start];

  while (queue.length !== 0) {
    const vert = queue.shift(); // Выбираем первую вершину из очереди

    if (tree[vert]) {
      queue.push(...tree[vert]); // Добавляем вершины в конец очереди
    }
  }
};

//! Пример кода в графе
const bfsGraph = (graph, start) => {
  const visited = {};
  const queue = [start];

  while (queue.length !== 0) {
    const vert = queue.shift(); // Выбираем первую вершину из очереди

    if (!visited[vert]) {
      visited[vert] = true; // Отмечаем вершину как пройденую, если ранее не проходили её
    }

    if (graph[vert]) {
      for (let subVert of graph[vert]) {
        if (!visited[subVert]) {
          queue.push(subVert); // Добавляем вершину в конец очереди
        }
      }
    }
  }
};


/*

*Сложность алгоритма: O(V + E).

Алгоритм следует использовать в следующих случаях:

Когда мы знаем, что искомая вершина находится близко к стартовой,
или если граф имеет большую глубину.

Когда нам необходимо найти кратчайшее расстояние в невзвешенном графе.

*/

//? Алгоритм Дейкстры
/*
Основная идея алгоритма — создание дерева кратчайших путей
с заданным источником в качестве корня.
Алгоритм Дейкстры — один из самых популярных алгоритмов
для нахождения короткого пути в взвешенном графе.
Незаменим в работе GPS-навигации.
*/

const getLowestCostNode = (queue) => {
  let min = Infinity;
  let lowIndex;

  for (let i = 0; i < queue.length; i++) {
    const [, value] = queue[i];
    if (value < min) {
      min = value;
      lowIndex = i;
    }
  }

  const lowestNode = queue.splice(lowIndex, 1)[0];
  return lowestNode;
};

const dijkstra = (graph, start) => {
  const parents = {};
  const costs = {};
  const queue = [];

  for (let vert in graph) {
    if (vert === start) {
      costs[vert] = 0;
      queue.push([vert, 0]);
    } else {
      costs[vert] = Infinity;
      queue.push([vert, Infinity]);
    }
    parents[vert] = null;
  }

  while (queue.length) {
    const node = getLowestCostNode(queue);
    let [vert, value] = node;
    const cost = costs[vert];

    if (node || value !== Infinity) {
      for (let subNode in graph[vert]) {
        const nextSubNodeValue = graph[vert][subNode];
        const newCost = cost + nextSubNodeValue;
          if (costs[subNode] > newCost) {
            costs[subNode] = newCost;
            parents[subNode] = vert;
            queue.push([subNode, newCost]);
          }
      }
    }
  }
};

/*

*Сложность алгоритма: O(E * log V)

*Алгоритм следует использовать в следующих случаях:

Когда необходимо найти кратчайший путь в взвешенном графе.
Когда граф не имеет отрицательных весов.

*/
